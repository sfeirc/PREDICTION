# PROFIT-OPTIMIZED Configuration for Crypto Trading
# Based on research and best practices for profitable crypto ML trading

# Data settings - MORE DATA = BETTER PREDICTIONS
data:
  symbols: ["BTCUSDT", "ETHUSDT"]
  train_symbol: "BTCUSDT"
  test_symbol: "ETHUSDT"
  interval: "1m"
  days: 30  # CRITICAL: Use 30+ days minimum (not 2!)
  cache_dir: "data/raw"
  processed_dir: "data/processed"

# Target settings - STRICTER THRESHOLDS = CLEANER SIGNALS
target:
  forward_minutes: 5
  up_threshold: 0.003    # 0.3% - STRICTER (research shows this works better)
  down_threshold: -0.003 # -0.3% - Fewer trades but higher quality
  
  # Multi-task learning
  multi_horizon: true
  horizons: [5, 10, 15]
  
  # ALWAYS balance classes for profitable trading
  balance_classes: true
  balancing_method: "downsample"

# Enhanced features - PROVEN PROFITABLE INDICATORS
features:
  # Core features
  returns_horizons: [1, 3, 5, 10, 15, 30]  # More horizons
  volatility_windows: [5, 15, 30, 60, 240]  # Include 1h and 4h
  volume_windows: [5, 15, 30, 60]
  
  # Technical indicators (research-proven)
  use_vwap: true
  use_rsi: true
  rsi_period: 14
  use_bollinger: true
  bollinger_period: 20
  bollinger_std: 2
  
  # Market microstructure
  use_orderbook: true
  orderbook_depth: 5
  
  # Time-of-day (proven to matter)
  use_time_features: true
  
  # Cross-asset (ETH can predict BTC)
  use_cross_asset: true
  
  # Event-based (only trade on significant moves)
  event_based_sampling: true
  event_thresholds:
    volume_spike: 2.5      # Higher threshold
    volatility_spike: 2.0  # Only strong signals
    spread_compression: 0.4

# Sequence settings
sequence:
  lookback_minutes: 60  # Longer lookback for better context

# Train/val/test split
split:
  train: 0.70
  val: 0.15
  test: 0.15

# Regime detection - TRADE ONLY IN FAVORABLE CONDITIONS
regime:
  enabled: true
  volatility_window: 1440
  low_percentile: 33
  high_percentile: 67

# Model hyperparameters - OPTIMIZED FOR PROFIT
models:
  lightgbm:
    n_estimators: 300      # More trees = better
    max_depth: 6           # Deeper trees
    learning_rate: 0.03    # Lower = more stable
    num_leaves: 48
    min_child_samples: 100  # Higher = less overfitting
    subsample: 0.7
    colsample_bytree: 0.7
    class_weight: "balanced"
    
  xgboost:
    n_estimators: 300
    max_depth: 6
    learning_rate: 0.03
    min_child_weight: 100
    subsample: 0.7
    colsample_bytree: 0.7
    scale_pos_weight: 1.0

# Training settings - CONSERVATIVE FOR PROFITABILITY
training:
  batch_size: 256
  epochs: 100
  learning_rate: 0.0005  # Lower for stability
  weight_decay: 1e-4
  early_stopping_patience: 15
  lr_scheduler: true
  scheduler_factor: 0.5
  scheduler_patience: 7
  grad_clip: 1.0
  
  # Loss function
  loss_type: "focal"
  focal_alpha: 0.25
  focal_gamma: 2.0
  label_smoothing: 0.1
  
  # CRITICAL: Higher confidence threshold = fewer but better trades
  min_confidence: 0.70  # Start at 70% (we know 75% works from find_optimal)

# Evaluation - PROFIT-FOCUSED
evaluation:
  metrics: ["accuracy", "auroc", "f1", "precision", "recall", "directional_accuracy"]
  baseline: "random"
  per_day_metrics: true
  per_regime_metrics: true
  
  # Trading simulation with RISK MANAGEMENT
  simulate_trading: true
  trading_cost: 0.001  # 0.1% per trade
  
  # Additional profit optimization
  stop_loss: 0.01      # 1% stop loss
  take_profit: 0.02    # 2% take profit (2:1 reward/risk)
  max_position_size: 0.25  # Max 25% of capital per trade

# Logging
logging:
  log_dir: "logs"
  use_wandb: false  # Disable for speed
  wandb_project: "crypto-price-prediction"
  checkpoint_dir: "checkpoints"
  save_best_only: true

# Reproducibility
seed: 42

# PROFIT OPTIMIZATION RULES
profit_rules:
  # Only trade in high-volatility regimes (more predictable)
  trade_only_high_vol: false  # DISABLED - was filtering too much
  
  # Only trade during high-liquidity hours (better execution)
  trade_hours_utc: []  # DISABLED - let confidence do the filtering
  
  # Minimum samples to train
  min_training_samples: 5000
  
  # Feature selection - use only top N most important
  use_top_n_features: false  # Use all features, let model decide

